// Generated by CoffeeScript 1.6.3
(function() {
  var Chocolate, io, mongoose, server, socketio, toRender, _;

  console.log("fire index.js");

  mongoose = require('mongoose');

  _ = require('underscore');

  toRender = {
    pageInfo: {
      title: 'Ranked Choice Voting',
      subtitle: 'A Case Study'
    },
    chocolates: ["Milk Chocolate", "Dark Chocolate", "White Chocolate", "Snickers", "Twix", "Cadbury", "Milky Way", "Hershey's"],
    cakes: ["Chocolate", "Red Velvet", "Ice Cream", "Hot Milk", "Birthday", "Wedding", "Angel Food", "Cakelette"],
    fruits: ["Banana", "Lemon", "Grape", "Kiwi", "Watermelon", "Apple", "Orange", "Dragonfruit"]
  };

  Chocolate = mongoose.model('Chocolate', {
    firstChoice: String,
    secondChoice: String,
    thirdChoice: String,
    choices: Array || String
  });

  server = require("./../app.js").server;

  socketio = require('socket.io');

  io = socketio.listen(server);

  module.exports = {
    index: function(req, res) {
      return res.render('index', toRender);
    },
    chocolate: function(req, res) {
      var chocolate, data, vote;
      data = req.query;
      console.log("data:::", data);
      vote = {
        firstChoice: data.type[0],
        secondChoice: data.type[1],
        thirdChoice: data.type[2],
        choices: toRender.chocolates
      };
      chocolate = new Chocolate(vote);
      return chocolate.save(function(err, data) {
        return console.log("sent to database:", data);
      });
    },
    tabulate: function(req, res) {
      console.log("made it to routes.tabulate");
      return Chocolate.find(function(err, votes) {
        var allVotes, choice, collectVotes, findVotesToRemove, followingRounds, next, reallocateVotes, roundStatus, secondRound, tabulatedObjectToRender, _i, _len, _ref;
        if (err) {
          return console.log('ERROR');
        } else {
          allVotes = _.map(votes, function(vote) {
            return vote;
          });
          collectVotes = function(votes) {
            var histogram, mappedGram, sortedMappedGram, totalVotes;
            totalVotes = votes.length;
            histogram = _.groupBy(votes, 'firstChoice');
            mappedGram = _.map(histogram, function(grouping) {
              var message, percentage;
              percentage = (100 * grouping.length) / totalVotes;
              if (percentage > 50) {
                message = "winner";
              } else {
                message = "";
              }
              return {
                firstChoice: grouping[0].firstChoice,
                secondChoice: grouping[0].secondChoice,
                thirdChoice: grouping[0].thirdChoice,
                votes: grouping.length,
                percentage: percentage,
                message: message
              };
            });
            return sortedMappedGram = _.sortBy(mappedGram, function(vote) {
              return vote.votes;
            });
          };
          findVotesToRemove = function(prevRoundResults) {
            var droppedChoices, fewestVotes, fewestVotesArray, remainingChoices;
            console.log("prevRoundResults", prevRoundResults);
            fewestVotes = prevRoundResults[0].votes;
            console.log("fewestVotes", fewestVotes);
            fewestVotesArray = _.where(prevRoundResults, {
              votes: prevRoundResults[0].votes
            });
            console.log("fewestVotesArray", fewestVotesArray);
            remainingChoices = prevRoundResults.slice(fewestVotesArray.length, prevRoundResults.length);
            console.log("remainingChoices", remainingChoices);
            if ((remainingChoices[0].votes + fewestVotes) < remainingChoices[1].votes) {
              console.log("remove next");
              fewestVotesArray.push(_.where(prevRoundResults, {
                votes: remainingChoices[0].votes
              }));
            }
            droppedChoices = _.map(fewestVotesArray, function(choice) {
              return choice.firstChoice;
            });
            return {
              droppedChoices: droppedChoices,
              remainingChoices: remainingChoices
            };
          };
          reallocateVotes = function(AllVotes, losersList, winnersList) {
            var addVotes, flattenedMatchedVotes, matchedVotes, rejectNullVotes, voteCount;
            matchedVotes = _.map(losersList, function(loser) {
              var findSecondVotes, secondVotes;
              findSecondVotes = _.where(AllVotes, {
                firstChoice: loser
              });
              return secondVotes = _.map(findSecondVotes, function(choice) {
                var found, thirdVotes;
                found = _.where(winnersList, {
                  firstChoice: choice.secondChoice
                });
                if (found[0]) {
                  return choice.secondChoice;
                } else {
                  return thirdVotes = _.map(findSecondVotes, function(nextChoice) {
                    var foundAgain;
                    foundAgain = _.where(winnersList, {
                      firstChoice: nextChoice.thirdChoice
                    });
                    if (foundAgain[0]) {
                      return nextChoice.thirdChoice;
                    } else {
                      return null;
                    }
                  });
                }
              });
            });
            flattenedMatchedVotes = _.flatten(matchedVotes);
            rejectNullVotes = _.reject(flattenedMatchedVotes, function(vote) {
              return vote === null;
            });
            voteCount = rejectNullVotes.reduce(function(acc, curr) {
              if (typeof acc[curr] === 'undefined') {
                acc[curr] = 1;
              } else {
                acc[curr] += 1;
              }
              return acc;
            }, {});
            console.log("voteCount", voteCount);
            addVotes = function(winnersList, voteCount) {
              var choice, currentChoices, totalVotes, vote, _i, _j, _k, _len, _len1, _len2;
              totalVotes = 0;
              for (_i = 0, _len = winnersList.length; _i < _len; _i++) {
                choice = winnersList[_i];
                for (vote in voteCount) {
                  if (choice.firstChoice === vote) {
                    choice.votes = choice.votes + voteCount[vote];
                  }
                }
              }
              currentChoices = _.map(winnersList, function(choice) {
                return choice.firstChoice;
              });
              for (_j = 0, _len1 = winnersList.length; _j < _len1; _j++) {
                choice = winnersList[_j];
                totalVotes += choice.votes;
              }
              for (_k = 0, _len2 = winnersList.length; _k < _len2; _k++) {
                choice = winnersList[_k];
                choice.percentage = (choice.votes * 100) / totalVotes;
                if (choice.percentage > 50) {
                  choice.message = "winner";
                }
              }
              console.log("winnersList", winnersList);
              return winnersList;
            };
            return addVotes(winnersList, voteCount);
          };
          collectVotes(allVotes);
          tabulatedObjectToRender = {
            title: "Tabulated Results",
            list: "Chocolate",
            firstRoundResults: collectVotes(allVotes).reverse()
          };
          next = true;
          roundStatus = 1;
          _ref = findVotesToRemove(collectVotes(allVotes)).remainingChoices;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            choice = _ref[_i];
            if (choice.message === "winner") {
              next = false;
            }
          }
          secondRound = function() {
            var firstRoundLosers, firstRoundWinners, reallocated;
            firstRoundLosers = findVotesToRemove(collectVotes(allVotes)).droppedChoices;
            firstRoundWinners = findVotesToRemove(collectVotes(allVotes)).remainingChoices;
            reallocated = _.sortBy(reallocateVotes(allVotes, firstRoundLosers, firstRoundWinners), function(obj) {
              return obj.votes;
            });
            return reallocated.reverse();
          };
          followingRounds = function() {
            var reallocated, roundLosers, roundResults, roundWinners;
            roundResults = findVotesToRemove(secondRound().reverse());
            roundLosers = findVotesToRemove(secondRound().reverse()).droppedChoices;
            roundWinners = findVotesToRemove(secondRound().reverse()).remainingChoices;
            reallocated = _.sortBy(reallocateVotes(allVotes, roundLosers, roundWinners), function(obj) {
              return obj.votes;
            });
            return reallocated.reverse();
          };
          if (next) {
            io.sockets.on('connection', function(socket) {
              var _j, _len1, _ref1, _results;
              console.log("SOCKET CONNECTED");
              roundStatus++;
              tabulatedObjectToRender.secondRoundResults = secondRound();
              _ref1 = secondRound();
              _results = [];
              for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                choice = _ref1[_j];
                console.log(choice);
                if (choice.message === "winner") {
                  console.log("no winner");
                  next = false;
                  if (next) {
                    _results.push(console.log("no_winner"));
                  } else {
                    _results.push(void 0);
                  }
                } else {
                  roundStatus++;
                  socket.emit('nextRound', {
                    next: true
                  });
                  _results.push(tabulatedObjectToRender.nextRoundResults = followingRounds());
                }
              }
              return _results;
            });
          }
          console.log('tabulate', tabulatedObjectToRender);
          return res.render('tabulate', tabulatedObjectToRender);
        }
      });
    }
  };

}).call(this);
