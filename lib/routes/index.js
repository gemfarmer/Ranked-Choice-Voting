// Generated by CoffeeScript 1.6.3
(function() {
  var Chocolate, mongoose, toRender, _;

  console.log("fire index.js");

  mongoose = require('mongoose');

  _ = require('underscore');

  toRender = {
    pageInfo: {
      title: 'Ranked Choice Voting',
      subtitle: 'A Case Study'
    },
    chocolates: ["Milk Chocolate", "Dark Chocolate", "White Chocolate", "Snickers", "Twix", "Cadbury", "Milky Way", "Hershey's"],
    cakes: ["Chocolate", "Red Velvet", "Ice Cream", "Hot Milk", "Birthday", "Wedding", "Angel Food", "Cakelette"],
    fruits: ["Banana", "Lemon", "Grape", "Kiwi", "Watermelon", "Apple", "Orange", "Dragonfruit"]
  };

  Chocolate = mongoose.model('Chocolate', {
    firstChoice: String,
    secondChoice: String,
    thirdChoice: String,
    choices: Array || String
  });

  module.exports = {
    index: function(req, res) {
      return res.render('index', toRender);
    },
    chocolate: function(req, res) {
      var chocolate, data, vote;
      data = req.query;
      console.log("data:::", data);
      vote = {
        firstChoice: data.type[0],
        secondChoice: data.type[1],
        thirdChoice: data.type[2],
        choices: toRender.chocolates
      };
      chocolate = new Chocolate(vote);
      return chocolate.save(function(err, data) {
        return console.log("sent to database:", data);
      });
    },
    tabulate: function(req, res) {
      console.log("made it to routes.tabulate");
      return Chocolate.find(function(err, votes) {
        var choice, collectVotes, findVotesToRemove, following, followingRounds, mappedVotes, next, reallocateVotes, roundStatus, second, secondRound, tabulatedObjectToRender, _i, _len, _ref;
        if (err) {
          return console.log('ERROR');
        } else {
          mappedVotes = _.map(votes, function(vote) {
            return vote;
          });
          console.log("mappedVotes", mappedVotes);
          collectVotes = function(votes) {
            var histogram, mappedGram, sortedMappedGram, totalVotes;
            totalVotes = votes.length;
            histogram = _.groupBy(votes, 'firstChoice');
            mappedGram = _.map(histogram, function(grouping) {
              var message, percentage;
              percentage = (100 * grouping.length) / totalVotes;
              if (percentage > 50) {
                message = "winner";
              } else {
                message = "";
              }
              return {
                firstChoice: grouping[0].firstChoice,
                secondChoice: grouping[0].secondChoice,
                thirdChoice: grouping[0].thirdChoice,
                votes: grouping.length,
                percentage: percentage,
                message: message
              };
            });
            return sortedMappedGram = _.sortBy(mappedGram, function(vote) {
              return vote.votes;
            });
          };
          findVotesToRemove = function(prevRoundResults) {
            var droppedChoices, fewestVotes, fewestVotesArray, remainingChoices;
            fewestVotes = prevRoundResults[0].votes;
            console.log("fewest votes::", fewestVotes);
            fewestVotesArray = _.where(prevRoundResults, {
              votes: prevRoundResults[0].votes
            });
            remainingChoices = prevRoundResults.slice(fewestVotesArray.length, prevRoundResults.length);
            if ((remainingChoices[0].votes + fewestVotes) < remainingChoices[1].votes) {
              console.log("remove next");
              fewestVotesArray.push(_.where(prevRoundResults, {
                votes: remainingChoices[0].votes
              }));
            }
            droppedChoices = _.map(fewestVotesArray, function(choice) {
              return choice.firstChoice;
            });
            return {
              droppedChoices: droppedChoices,
              remainingChoices: remainingChoices
            };
          };
          reallocateVotes = function(AllVotes, firstRoundLosers, firstRoundWinners) {
            var addVotes, flattenedMatchedVotes, matchedVotes, rejectNullVotes, voteCount;
            console.log("firstRoundWinners", firstRoundWinners);
            matchedVotes = _.map(firstRoundLosers, function(loser) {
              var findSecondVotes, secondVotes;
              findSecondVotes = _.where(AllVotes, {
                firstChoice: loser
              });
              return secondVotes = _.map(findSecondVotes, function(choice) {
                var found, thirdVotes;
                found = _.where(firstRoundWinners, {
                  firstChoice: choice.secondChoice
                });
                if (found[0]) {
                  return choice.secondChoice;
                } else {
                  return thirdVotes = _.map(findSecondVotes, function(nextChoice) {
                    var foundAgain;
                    foundAgain = _.where(firstRoundWinners, {
                      firstChoice: nextChoice.thirdChoice
                    });
                    if (foundAgain[0]) {
                      return nextChoice.thirdChoice;
                    } else {
                      return null;
                    }
                  });
                }
              });
            });
            flattenedMatchedVotes = _.flatten(matchedVotes);
            rejectNullVotes = _.reject(flattenedMatchedVotes, function(vote) {
              return vote === null;
            });
            console.log("rejects", rejectNullVotes);
            voteCount = rejectNullVotes.reduce(function(acc, curr) {
              if (typeof acc[curr] === 'undefined') {
                acc[curr] = 1;
              } else {
                acc[curr] += 1;
              }
              return acc;
            }, {});
            console.log("VOTE", voteCount.vote);
            console.log("voteCount", voteCount);
            addVotes = function(firstRoundWinners, voteCount) {
              var choice, currentChoices, totalVotes, vote, _i, _j, _k, _len, _len1, _len2;
              totalVotes = 0;
              for (_i = 0, _len = firstRoundWinners.length; _i < _len; _i++) {
                choice = firstRoundWinners[_i];
                for (vote in voteCount) {
                  if (choice.firstChoice === vote) {
                    console.log("choice.votes", choice.votes);
                    console.log("voteCount.vote", voteCount[vote]);
                    choice.votes = choice.votes + voteCount[vote];
                  }
                }
              }
              console.log("total:", totalVotes);
              currentChoices = _.map(firstRoundWinners, function(choice) {
                return choice.firstChoice;
              });
              for (_j = 0, _len1 = firstRoundWinners.length; _j < _len1; _j++) {
                choice = firstRoundWinners[_j];
                totalVotes += choice.votes;
              }
              for (_k = 0, _len2 = firstRoundWinners.length; _k < _len2; _k++) {
                choice = firstRoundWinners[_k];
                choice.percentage = (choice.votes * 100) / totalVotes;
                if (choice.percentage > 50) {
                  choice.message = "winner";
                }
              }
              return firstRoundWinners;
            };
            return addVotes(firstRoundWinners, voteCount);
          };
          collectVotes(mappedVotes);
          tabulatedObjectToRender = {
            title: "Tabulated Results",
            list: "Chocolate",
            firstRoundResults: collectVotes(mappedVotes).reverse()
          };
          next = true;
          roundStatus = 1;
          console.log("next", next);
          _ref = findVotesToRemove(collectVotes(mappedVotes)).remainingChoices;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            choice = _ref[_i];
            if (choice.message === "winner") {
              next = false;
            }
          }
          secondRound = function() {
            var firstRoundLosers, firstRoundWinners, reallocated;
            firstRoundLosers = findVotesToRemove(collectVotes(mappedVotes)).droppedChoices;
            firstRoundWinners = findVotesToRemove(collectVotes(mappedVotes)).remainingChoices;
            reallocated = reallocateVotes(mappedVotes, firstRoundLosers, firstRoundWinners).sort().reverse();
            tabulatedObjectToRender.secondRoundResults = reallocated;
            return reallocated;
          };
          followingRounds = function() {
            var reallocated, roundLosers, roundWinners;
            roundLosers = findVotesToRemove(secondRound()).droppedChoices;
            console.log("roundLosers", roundLosers);
            roundWinners = findVotesToRemove(secondRound()).remainingChoices;
            console.log("roundWinners", roundWinners);
            reallocated = reallocateVotes(secondRound(), roundLosers, roundWinners).sort().reverse();
            tabulatedObjectToRender.nextRoundResults = reallocated;
            return reallocated;
          };
          if (next) {
            roundStatus++;
            second = secondRound();
            console.log("second", second);
            following = followingRounds();
            console.log("following", following);
          }
          return res.render('tabulate', tabulatedObjectToRender);
        }
      });
    }
  };

}).call(this);
