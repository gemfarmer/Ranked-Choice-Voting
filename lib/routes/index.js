// Generated by CoffeeScript 1.6.3
(function() {
  var Chocolate, mongoose, toRender, _;

  console.log("fire index.js");

  mongoose = require('mongoose');

  _ = require('underscore');

  toRender = {
    pageInfo: {
      title: 'Ranked Choice Voting',
      subtitle: 'A Case Study'
    },
    chocolates: ["Milk Chocolate", "Dark Chocolate", "White Chocolate", "Snickers", "Twix", "Cadbury", "Milky Way", "Hershey's"],
    cakes: ["Chocolate", "Red Velvet", "Ice Cream", "Hot Milk", "Birthday", "Wedding", "Angel Food", "Cakelette"],
    fruits: ["Banana", "Lemon", "Grape", "Kiwi", "Watermelon", "Apple", "Orange", "Dragonfruit"]
  };

  Chocolate = mongoose.model('Chocolate', {
    firstChoice: String,
    secondChoice: String,
    thirdChoice: String,
    choices: Array || String
  });

  module.exports = {
    index: function(req, res) {
      return res.render('index', toRender);
    },
    chocolate: function(req, res) {
      var chocolate, data, vote;
      data = req.query;
      console.log("data:::", data);
      vote = {
        firstChoice: data.type[0],
        secondChoice: data.type[1],
        thirdChoice: data.type[2],
        choices: toRender.chocolates
      };
      chocolate = new Chocolate(vote);
      return chocolate.save(function(err, data) {
        return console.log("sent to database:", data);
      });
    },
    tabulate: function(req, res) {
      console.log("made it to routes.tabulate");
      return Chocolate.find(function(err, votes) {
        var findVotesToRemove, firstRoundLosers, firstRoundWinners, histogram, mappedGram, mappedVotes, realocateVotes, sortedMappedGram, tabulatedObjectToRender, totalVotes;
        if (err) {
          return console.log('ERROR');
        } else {
          mappedVotes = _.map(votes, function(vote) {
            return vote;
          });
          totalVotes = mappedVotes.length;
          histogram = _.groupBy(mappedVotes, 'firstChoice');
          mappedGram = _.map(histogram, function(grouping) {
            var firstChoice, message, percentage, secondChoice, thirdChoice;
            firstChoice = grouping[0].firstChoice;
            secondChoice = grouping[0].secondChoice;
            thirdChoice = grouping[0].thirdChoice;
            percentage = (100 * grouping.length) / totalVotes;
            if (percentage > 50) {
              message = "Winner!";
            } else {
              message = "";
            }
            return {
              firstChoice: firstChoice,
              secondChoice: secondChoice,
              thirdChoice: thirdChoice,
              votes: grouping.length,
              percentage: percentage,
              message: message
            };
          });
          sortedMappedGram = _.sortBy(mappedGram, function(vote) {
            return vote.votes;
          });
          findVotesToRemove = function(prevRoundResults) {
            var choicesToDrop, fewestVotes, fewestVotesArray, remainingChoices;
            fewestVotes = prevRoundResults[0].votes;
            fewestVotesArray = _.where(prevRoundResults, {
              votes: prevRoundResults[0].votes
            });
            remainingChoices = prevRoundResults.slice(fewestVotesArray.length, prevRoundResults.length);
            if ((remainingChoices[0].votes + fewestVotes) < remainingChoices[1].votes) {
              console.log("remove next");
              fewestVotesArray.push(_.where(prevRoundResults, {
                votes: remainingChoices[0].votes
              }));
            }
            choicesToDrop = _.map(fewestVotesArray, function(choice) {
              return choice.firstChoice;
            });
            return {
              choicesToDrop: choicesToDrop,
              remainingChoices: remainingChoices
            };
          };
          console.log("findVotesToRemove", findVotesToRemove(sortedMappedGram));
          firstRoundLosers = findVotesToRemove(sortedMappedGram).choicesToDrop;
          firstRoundWinners = findVotesToRemove(sortedMappedGram).remainingChoices;
          realocateVotes = function(AllVotes, firstRoundLosers, firstRoundWinners) {
            var matchedVotes;
            matchedVotes = _.map(firstRoundLosers, function(vote) {
              var findSecondVotes, secondVotes;
              findSecondVotes = _.where(AllVotes, {
                firstChoice: vote
              });
              console.log("findSecondVotes", findSecondVotes);
              return secondVotes = _.each(findSecondVotes, function(choice) {
                var thirdVotes;
                console.log("choice:::vote", choice, ":::", vote);
                if (_.where(firstRoundWinners, {
                  firstChoice: vote
                })) {
                  return choice.secondChoice;
                } else {
                  thirdVotes = _.each(findSecondVotes, function(nextChoice) {
                    if (_.where(firstRoundWinners, {
                      firstChoice: vote
                    })) {
                      return vote;
                    }
                  });
                  return console.log("not matched. find third vote", vote);
                }
              });
            });
            return console.log("matchedVotes", matchedVotes);
          };
          realocateVotes(mappedVotes, firstRoundLosers, firstRoundWinners);
          tabulatedObjectToRender = {
            title: "Tabulated Results",
            choice: "chocolate",
            firstRoundResults: sortedMappedGram.reverse(),
            secondRoundResults: "second round results"
          };
          return res.render('tabulate', tabulatedObjectToRender);
        }
      });
    }
  };

}).call(this);
