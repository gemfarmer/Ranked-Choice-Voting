// Generated by CoffeeScript 1.6.3
(function() {
  var Chocolate, mongoose, toRender, _;

  console.log("fire index.js");

  mongoose = require('mongoose');

  _ = require('underscore');

  toRender = {
    pageInfo: {
      title: 'Ranked Choice Voting',
      subtitle: 'A Case Study'
    },
    chocolates: ["Milk Chocolate", "Dark Chocolate", "White Chocolate", "Snickers", "Twix", "Cadbury", "Milky Way", "Hershey's"],
    cakes: ["Chocolate", "Red Velvet", "Ice Cream", "Hot Milk", "Birthday", "Wedding", "Angel Food", "Cakelette"],
    fruits: ["Banana", "Lemon", "Grape", "Kiwi", "Watermelon", "Apple", "Orange", "Dragonfruit"]
  };

  Chocolate = mongoose.model('Chocolate', {
    firstChoice: String,
    secondChoice: String,
    thirdChoice: String,
    choices: Array || String
  });

  module.exports = {
    index: function(req, res) {
      return res.render('index', toRender);
    },
    chocolate: function(req, res) {
      var chocolate, data, vote;
      data = req.query;
      console.log("data:::", data);
      vote = {
        firstChoice: data.type[0],
        secondChoice: data.type[1],
        thirdChoice: data.type[2],
        choices: toRender.chocolates
      };
      chocolate = new Chocolate(vote);
      return chocolate.save(function(err, data) {
        return console.log("sent to database:", data);
      });
    },
    tabulate: function(req, res) {
      console.log("made it to routes.tabulate");
      return Chocolate.find(function(err, votes) {
        var collectVotes, findVotesToRemove, firstRoundLosers, firstRoundWinners, mappedVotes, realocateVotes, tabulatedObjectToRender;
        if (err) {
          return console.log('ERROR');
        } else {
          mappedVotes = _.map(votes, function(vote) {
            return vote;
          });
          collectVotes = function(votes, additionalVotes) {
            var histogram, mappedGram, sortedMappedGram, totalVotes;
            totalVotes = votes.length;
            histogram = _.groupBy(votes, 'firstChoice');
            mappedGram = _.map(histogram, function(grouping) {
              var message, percentage;
              percentage = (100 * grouping.length) / totalVotes;
              if (percentage > 50) {
                message = "Winner!";
              } else {
                message = "";
              }
              return {
                firstChoice: grouping[0].firstChoice,
                secondChoice: grouping[0].secondChoice,
                thirdChoice: grouping[0].thirdChoice,
                votes: grouping.length,
                percentage: percentage,
                message: message
              };
            });
            return sortedMappedGram = _.sortBy(mappedGram, function(vote) {
              return vote.votes;
            });
          };
          findVotesToRemove = function(prevRoundResults) {
            var droppedChoices, fewestVotes, fewestVotesArray, remainingChoices;
            fewestVotes = prevRoundResults[0].votes;
            fewestVotesArray = _.where(prevRoundResults, {
              votes: prevRoundResults[0].votes
            });
            remainingChoices = prevRoundResults.slice(fewestVotesArray.length, prevRoundResults.length);
            if ((remainingChoices[0].votes + fewestVotes) < remainingChoices[1].votes) {
              console.log("remove next");
              fewestVotesArray.push(_.where(prevRoundResults, {
                votes: remainingChoices[0].votes
              }));
            }
            droppedChoices = _.map(fewestVotesArray, function(choice) {
              return choice.firstChoice;
            });
            return {
              droppedChoices: droppedChoices,
              remainingChoices: remainingChoices
            };
          };
          console.log("findVotesToRemove", findVotesToRemove(collectVotes(mappedVotes)));
          firstRoundLosers = findVotesToRemove(collectVotes(mappedVotes)).droppedChoices;
          firstRoundWinners = findVotesToRemove(collectVotes(mappedVotes)).remainingChoices;
          realocateVotes = function(AllVotes, firstRoundLosers, firstRoundWinners) {
            var flattenedMatchedVotes, matchedVotes, rejectNullVotes;
            console.log("firstRoundWinners", firstRoundWinners);
            matchedVotes = _.map(firstRoundLosers, function(loser) {
              var findSecondVotes, secondVotes;
              findSecondVotes = _.where(AllVotes, {
                firstChoice: loser
              });
              return secondVotes = _.map(findSecondVotes, function(choice) {
                var found, thirdVotes;
                found = _.where(firstRoundWinners, {
                  firstChoice: choice.secondChoice
                });
                if (found[0]) {
                  return choice.secondChoice;
                } else {
                  return thirdVotes = _.map(findSecondVotes, function(nextChoice) {
                    var foundAgain;
                    foundAgain = _.where(firstRoundWinners, {
                      firstChoice: nextChoice.thirdChoice
                    });
                    if (foundAgain[0]) {
                      return nextChoice.thirdChoice;
                    } else {
                      return null;
                    }
                  });
                }
              });
            });
            flattenedMatchedVotes = _.flatten(matchedVotes);
            rejectNullVotes = _.reject(flattenedMatchedVotes, function(vote) {
              return vote === null;
            });
            return console.log(flattenedMatchedVotes, rejectNullVotes);
          };
          realocateVotes(mappedVotes, firstRoundLosers, firstRoundWinners);
          tabulatedObjectToRender = {
            title: "Tabulated Results",
            choice: "chocolate",
            firstRoundResults: collectVotes(mappedVotes).reverse(),
            secondRoundResults: collectVotes(mappedVotes).reverse()
          };
          return res.render('tabulate', tabulatedObjectToRender);
        }
      });
    }
  };

}).call(this);
